# Tribal Knowledge Deep Agent - Architecture Diagrams

This document contains comprehensive mermaid diagrams showing the system architecture from multiple perspectives.

---

## 1. High-Level System Architecture

```mermaid
graph TB
    subgraph "Tribal Knowledge Deep Agent"
        PLANNER[Planner<br/>Schema Analyzer]
        AGENT1[Agent 1<br/>Database Documenter]
        AGENT2[Agent 2<br/>Document Indexer]
        AGENT3[Agent 3<br/>Index Retrieval]
        
        subgraph "Sub-Agents"
            TABLEDOC[TableDocumenter]
            COLINF[ColumnInferencer]
        end
        
        PLANNER -->|plan.json| AGENT1
        AGENT1 -->|spawns| TABLEDOC
        TABLEDOC -->|spawns| COLINF
        AGENT1 -->|docs/| AGENT2
        AGENT2 -->|SQLite| AGENT3
        
        subgraph "Storage"
            PLANFILE[documentation-plan.json]
            FILESYSTEM[Filesystem<br/>/docs/]
            SQLITE[SQLite DB<br/>FTS5 + Vectors]
        end
        
        PLANNER --> PLANFILE
        AGENT1 --> FILESYSTEM
        AGENT2 --> SQLITE
        AGENT3 --> SQLITE
        
        subgraph "Prompt Templates"
            PROMPTS[/prompts/<br/>column-description.md<br/>table-description.md<br/>domain-inference.md<br/>query-understanding.md]
        end
        
        PLANNER -.->|uses| PROMPTS
        TABLEDOC -.->|uses| PROMPTS
        COLINF -.->|uses| PROMPTS
        AGENT3 -.->|uses| PROMPTS
    end
    
    subgraph "External Systems"
        DBS[(Databases<br/>PostgreSQL<br/>Snowflake)]
        EXTMCP[External MCP Repo<br/>Noah's Company MCP]
        LLM[LLM APIs<br/>OpenAI<br/>Anthropic]
    end
    
    PLANNER -->|connects| DBS
    AGENT1 -->|connects| DBS
    AGENT1 -->|calls| LLM
    AGENT2 -->|calls| LLM
    AGENT3 -->|functions| EXTMCP
    EXTMCP -->|queries| AGENT3
    
    style PLANNER fill:#e1f5ff
    style AGENT1 fill:#e1f5ff
    style AGENT2 fill:#e1f5ff
    style AGENT3 fill:#e1f5ff
    style TABLEDOC fill:#fff4e1
    style COLINF fill:#fff4e1
    style PLANFILE fill:#e8f5e9
    style FILESYSTEM fill:#e8f5e9
    style SQLITE fill:#e8f5e9
```

---

## 2. Agent Chain Flow

```mermaid
flowchart TD
    START[User Trigger<br/>npm run plan] --> PLANNER
    
    subgraph "Planner: Schema Analyzer"
        PLANNER[Planner] --> CONNECT[Connect to Databases]
        CONNECT --> COUNT[Count Tables]
        COUNT --> EXTRACT[Extract Metadata<br/>for ALL tables]
        EXTRACT --> DETECT[Detect Domains<br/>via LLM]
        DETECT --> CREATE[Create Plan<br/>documentation-plan.json]
    end
    
    CREATE --> PLANFILE[documentation-plan.json<br/>Contains complete metadata]
    PLANFILE --> REVIEW[User Reviews Plan]
    REVIEW --> DOCSTART[User Trigger<br/>npm run document]
    
    subgraph "Agent 1: Documenter"
        DOCSTART --> LOAD[Load Plan]
        LOAD --> SPAWN[Spawn TableDocumenter<br/>for each plan entry]
        
        subgraph "Sub-Agent: TableDocumenter"
            SPAWN --> RECEIVE[Receive Metadata<br/>from Plan]
            RECEIVE --> SAMPLE[Sample Data]
            SAMPLE --> COLSPAWN[Spawn ColumnInferencer<br/>for each column]
            
            subgraph "Sub-Agent: ColumnInferencer"
                COLSPAWN --> LOADPROMPT[Load Prompt Template]
                LOADPROMPT --> CALL[Call LLM]
                CALL --> RETURN[Return Description]
            end
            
            RETURN --> ASSEMBLE[Assemble Documentation]
            ASSEMBLE --> WRITE[Write .md + .json files]
            WRITE --> SUMMARY[Return Summary]
        end
        
        SUMMARY --> CHECKPOINT[Update Progress]
        CHECKPOINT --> MORE{More tables?}
        MORE -->|Yes| SPAWN
        MORE -->|No| AGGREGATE[Generate Aggregate Outputs]
    end
    
    AGGREGATE --> DOCFILES[/docs/ filesystem]
    DOCFILES --> INDEXSTART[User Trigger<br/>npm run index]
    
    subgraph "Agent 2: Indexer"
        INDEXSTART --> PARSE[Parse Documentation]
        PARSE --> EXTRACTKW[Extract Keywords]
        EXTRACTKW --> GENEMB[Generate Embeddings]
        GENEMB --> BUILD[Build Index<br/>FTS5 + Vector]
    end
    
    BUILD --> SQLITEDB[(SQLite DB<br/>tribal-knowledge.db)]
    SQLITEDB --> RETRIEVAL[Agent 3: Retrieval<br/>Functions ready]
    
    RETRIEVAL --> EXTMCP[External MCP<br/>Calls Functions]
    
    style PLANNER fill:#e1f5ff
    style DOCSTART fill:#e1f5ff
    style INDEXSTART fill:#e1f5ff
    style RECEIVE fill:#fff4e1
    style COLSPAWN fill:#fff4e1
    style PLANFILE fill:#e8f5e9
    style DOCFILES fill:#e8f5e9
    style SQLITEDB fill:#e8f5e9
```

---

## 3. Data Flow Architecture

```mermaid
flowchart LR
    subgraph "Source"
        PG[(PostgreSQL)]
        SF[(Snowflake)]
    end
    
    subgraph "Planner Phase"
        PLANNER[Schema Analyzer] -->|Extracts ALL metadata| PLAN[documentation-plan.json<br/>Complete metadata for all tables]
    end
    
    PG -->|connection| PLANNER
    SF -->|connection| PLANNER
    
    PLAN -->|input| DOCUMENTER[Documenter]
    
    subgraph "Documentation Phase"
        DOCUMENTER -->|spawns with metadata| TABLEDOC[TableDocumenter<br/>Receives metadata from plan]
        TABLEDOC -->|samples| PG
        TABLEDOC -->|samples| SF
        TABLEDOC -->|calls| LLM1[Claude API<br/>Semantic Inference]
        TABLEDOC -->|generates| DOCS[Markdown Files<br/>JSON Files<br/>YAML Files]
    end
    
    DOCS -->|reads| INDEXER[Indexer]
    
    subgraph "Indexing Phase"
        INDEXER -->|calls| LLM2[OpenAI API<br/>Embeddings]
        INDEXER -->|writes| DB[(SQLite DB<br/>FTS5 + Vectors)]
    end
    
    subgraph "Retrieval Phase"
        DB -->|queries| RETRIEVAL[Retrieval Functions]
        RETRIEVAL -->|calls| LLM3[Query Understanding]
        RETRIEVAL -->|returns| EXTMCP[External MCP]
    end
    
    style PLANNER fill:#e1f5ff
    style DOCUMENTER fill:#e1f5ff
    style INDEXER fill:#e1f5ff
    style RETRIEVAL fill:#e1f5ff
    style TABLEDOC fill:#fff4e1
    style PLAN fill:#e8f5e9
    style DOCS fill:#e8f5e9
    style DB fill:#e8f5e9
```

---

## 4. Sub-Agent Architecture Detail

```mermaid
graph TB
    DOCUMENTER[Documenter<br/>Agent 1] -->|For each table in plan| SPAWN[Spawn TableDocumenter]
    
    subgraph "TableDocumenter Sub-Agent"
        SPAWN --> RECEIVE[Receive Complete Metadata<br/>from documentation-plan.json]
        RECEIVE --> VALIDATE[Validate Metadata Structure]
        VALIDATE --> SAMPLE[Sample Data from Table<br/>100 rows max]
        SAMPLE --> COLSPAWN[Spawn ColumnInferencer<br/>for each column]
        
        COLSPAWN --> COLLECT[Collect Column Descriptions]
        COLLECT --> TABLEDESC[Generate Table Description<br/>via LLM + prompt template]
        TABLEDESC --> ASSEMBLE[Assemble Documentation]
        ASSEMBLE --> WRITE[Write Files<br/>.md, .json, .yaml]
        WRITE --> RETURN[Return Summary<br/>Context Quarantine]
    end
    
    subgraph "ColumnInferencer Sub-Agent"
        COLSPAWN --> COLRECEIVE[Receive Column Metadata]
        COLRECEIVE --> LOADPROMPT[Load column-description.md]
        LOADPROMPT --> FORMAT[Format Prompt<br/>with variables]
        FORMAT --> CALL[Call Claude API]
        CALL --> PARSE[Parse Response]
        PARSE --> COLRETURN[Return Description String<br/>Context Quarantine]
    end
    
    COLRETURN --> COLLECT
    RETURN --> DOCUMENTER
    
    subgraph "Key Principles"
        PRINCIPLE1[Context Quarantine<br/>Sub-agents return summaries only]
        PRINCIPLE2[Metadata from Plan<br/>No extraction needed]
        PRINCIPLE3[Isolated Tasks<br/>One responsibility per sub-agent]
    end
    
    style DOCUMENTER fill:#e1f5ff
    style SPAWN fill:#fff4e1
    style COLSPAWN fill:#fff4e1
    style RETURN fill:#e8f5e9
    style COLRETURN fill:#e8f5e9
```

---

## 5. Storage Architecture

```mermaid
graph TB
    subgraph "Filesystem Storage"
        DOCS[/docs/]
        DOCS --> CATALOG[catalog-summary.md]
        DOCS --> DBS[databases/]
        
        DBS --> DB1[production_postgres/]
        DB1 --> TABLES1[tables/<br/>*.md, *.json]
        DB1 --> DOMAINS1[domains/<br/>*.md, *.mermaid]
        DB1 --> ER1[er-diagrams/<br/>*.mermaid]
        DB1 --> SCHEMAS1[schemas/<br/>*.json, *.yaml]
        
        DBS --> DB2[analytics_snowflake/]
        DB2 --> TABLES2[tables/]
        DB2 --> DOMAINS2[domains/]
        DB2 --> ER2[er-diagrams/]
        DB2 --> SCHEMAS2[schemas/]
        
        PROGRESS[progress/]
        PROGRESS --> PLANFILE[documentation-plan.json]
        PROGRESS --> DOCPROG[documenter-progress.json]
        PROGRESS --> IDXPROG[indexer-progress.json]
    end
    
    subgraph "SQLite Database"
        SQLITE[(tribal-knowledge.db)]
        
        SQLITE --> DOCS_TABLE[documents table<br/>id, type, content, metadata]
        SQLITE --> FTS5[documents_fts<br/>FTS5 full-text search]
        SQLITE --> VEC[documents_vec<br/>Vector embeddings]
        SQLITE --> REL[relationships table<br/>Join paths, FKs]
        SQLITE --> KW[keywords table<br/>Term cache]
        SQLITE --> WEIGHTS[index_weights<br/>Search boosts]
        
        DOCS_TABLE --> FTS5
        DOCS_TABLE --> VEC
    end
    
    subgraph "Prompt Templates"
        PROMPTS[/prompts/]
        PROMPTS --> COLPROMPT[column-description.md]
        PROMPTS --> TABPROMPT[table-description.md]
        PROMPTS --> DOMPROMPT[domain-inference.md]
        PROMPTS --> QUERYPROMPT[query-understanding.md]
    end
    
    DOCS -.->|indexed by| SQLITE
    PLANFILE -.->|used by| DOCUMENTER[Documenter]
    
    style DOCS fill:#e8f5e9
    style SQLITE fill:#e8f5e9
    style PROMPTS fill:#fff4e1
    style PROGRESS fill:#e1f5ff
```

---

## 6. Integration Architecture

```mermaid
graph TB
    subgraph "Tribal Knowledge Repo"
        RETRIEVAL[Retrieval Functions<br/>Agent 3]
        
        RETRIEVAL --> SEARCH[search_tables]
        RETRIEVAL --> SCHEMA[get_table_schema]
        RETRIEVAL --> JOIN[get_join_path]
        RETRIEVAL --> DOMAIN[get_domain_overview]
        RETRIEVAL --> LIST[list_domains]
        RETRIEVAL --> RELS[get_common_relationships]
        
        SEARCH --> HYBRID[Hybrid Search<br/>FTS5 + Vector + RRF]
        SCHEMA --> LOOKUP[Direct Lookup]
        JOIN --> GRAPH[Relationship Graph]
        DOMAIN --> QUERY[Domain Query]
        LIST --> DISTINCT[Distinct Query]
        RELS --> PATTERNS[Pattern Query]
        
        HYBRID --> SQLITE[(SQLite DB)]
        LOOKUP --> SQLITE
        GRAPH --> SQLITE
        QUERY --> SQLITE
        DISTINCT --> SQLITE
        PATTERNS --> SQLITE
    end
    
    subgraph "External MCP Repo"
        MCP[MCP Server]
        MCP --> TOOL1[MCP Tool: search_tables]
        MCP --> TOOL2[MCP Tool: get_table_schema]
        MCP --> TOOL3[MCP Tool: get_join_path]
        MCP --> TOOL4[MCP Tool: get_domain_overview]
        MCP --> TOOL5[MCP Tool: list_domains]
        MCP --> TOOL6[MCP Tool: get_common_relationships]
    end
    
    subgraph "External Agents"
        AGENT[AI Agent<br/>via MCP]
        AGENT -->|calls| MCP
    end
    
    TOOL1 -.->|calls| SEARCH
    TOOL2 -.->|calls| SCHEMA
    TOOL3 -.->|calls| JOIN
    TOOL4 -.->|calls| DOMAIN
    TOOL5 -.->|calls| LIST
    TOOL6 -.->|calls| RELS
    
    style RETRIEVAL fill:#e1f5ff
    style MCP fill:#fff4e1
    style AGENT fill:#e8f5e9
    style SQLITE fill:#e8f5e9
```

---

## 7. Orchestrator Architecture (Future)

```mermaid
graph TB
    USER[User] -->|npm run orchestrate| ORCH[Orchestrator]
    
    subgraph "Orchestrator"
        ORCH --> STATE[State Manager<br/>Analyzes filesystem state]
        STATE --> DECIDE[Decision Logic<br/>What needs to run?]
        DECIDE --> RUNNER[Phase Runner]
        
        RUNNER -->|calls| PLANNER[Planner]
        RUNNER -->|calls| DOCUMENTER[Documenter]
        RUNNER -->|calls| INDEXER[Indexer]
        RUNNER -->|calls| SERVE[Serve]
        
        RUNNER --> UI[Interactive UI<br/>Pause points, prompts]
        UI --> USER
    end
    
    subgraph "State Detection"
        STATE --> CHECK1{Plan exists?}
        STATE --> CHECK2{Docs fresh?}
        STATE --> CHECK3{Index fresh?}
        STATE --> CHECK4{Config changed?}
    end
    
    CHECK1 -->|No| REC1[Recommend: Run plan]
    CHECK2 -->|No| REC2[Recommend: Run document]
    CHECK3 -->|No| REC3[Recommend: Run index]
    CHECK4 -->|Yes| REC1
    
    REC1 --> RUNNER
    REC2 --> RUNNER
    REC3 --> RUNNER
    
    style ORCH fill:#e1f5ff
    style STATE fill:#fff4e1
    style RUNNER fill:#fff4e1
    style UI fill:#e8f5e9
```

---

## 8. Component Relationships

```mermaid
graph LR
    subgraph "Core Agents"
        P[Planner]
        D[Documenter]
        I[Indexer]
        R[Retrieval]
    end
    
    subgraph "Sub-Agents"
        TD[TableDocumenter]
        CI[ColumnInferencer]
    end
    
    subgraph "Connectors"
        PG[PostgreSQL Connector]
        SF[Snowflake Connector]
    end
    
    subgraph "Search"
        HYBRID[Hybrid Search]
        FTS5[FTS5 Engine]
        VEC[Vector Search]
        RRF[RRF Ranking]
    end
    
    subgraph "Storage"
        PLAN[Plan File]
        FS[Filesystem]
        DB[(SQLite)]
    end
    
    subgraph "External"
        LLM[LLM APIs]
        PROMPTS[Prompt Templates]
        EXTMCP[External MCP]
    end
    
    P --> PG
    P --> SF
    P --> LLM
    P --> PROMPTS
    P --> PLAN
    
    D --> PLAN
    D --> TD
    TD --> CI
    TD --> PG
    TD --> SF
    TD --> LLM
    TD --> PROMPTS
    D --> FS
    
    I --> FS
    I --> LLM
    I --> DB
    
    R --> DB
    R --> HYBRID
    HYBRID --> FTS5
    HYBRID --> VEC
    HYBRID --> RRF
    R --> PROMPTS
    R --> EXTMCP
    
    style P fill:#e1f5ff
    style D fill:#e1f5ff
    style I fill:#e1f5ff
    style R fill:#e1f5ff
    style TD fill:#fff4e1
    style CI fill:#fff4e1
    style PLAN fill:#e8f5e9
    style FS fill:#e8f5e9
    style DB fill:#e8f5e9
```

---

## Key Architectural Principles

1. **Planner Handles Table Iteration**: The Schema Analyzer extracts ALL metadata for ALL tables upfront. The Documenter spawns sub-agents based on plan entries, not by iterating tables itself.

2. **Context Quarantine**: Sub-agents return summaries only, not raw data. This prevents context window overflow.

3. **Metadata from Plan**: TableDocumenter receives complete metadata from the plan - no need to query information_schema again.

4. **MCP in Separate Repo**: MCP tools are implemented in another repository. This repo provides retrieval functions that external MCP calls.

5. **Manual Triggers**: All phases are user-triggered (no autonomous execution).

6. **Hybrid Search**: Combines FTS5 (keyword) + vector embeddings (semantic) with Reciprocal Rank Fusion for optimal results.

