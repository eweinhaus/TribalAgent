# Tribal Knowledge Deep Agent - System Architecture

This document contains comprehensive mermaid diagrams showing the deep agent system architecture from multiple perspectives, incorporating domain-based parallelization, work units, and the four pillars of deep agent design.

---

## 1. High-Level System Architecture

```mermaid
graph TB
    subgraph "Tribal Knowledge Deep Agent"
        ORCHESTRATOR[Orchestrator<br/>Pipeline Coordinator]

        PLANNER[Planner<br/>Schema Analyzer]
        AGENT1[Agent 1<br/>Database Documenter]
        AGENT2[Agent 2<br/>Document Indexer]
        AGENT3[Agent 3<br/>Index Retrieval]

        subgraph "Sub-Agents"
            TABLEDOC[TableDocumenter<br/>Per Table]
            COLINF[ColumnInferencer<br/>Per Column]
        end

        ORCHESTRATOR -->|coordinates| PLANNER
        PLANNER -->|work units| AGENT1
        AGENT1 -->|spawns| TABLEDOC
        TABLEDOC -->|spawns| COLINF
        AGENT1 -->|manifest| AGENT2
        AGENT2 -->|SQLite| AGENT3
        
    subgraph "Storage"
        ORCHSTATE[orchestrator-state.json<br/>Pipeline state]
        PLANFILE[documentation-plan.json<br/>Work units by domain]
        FILESYSTEM[Filesystem<br/>/docs/ + /progress/]
        SQLITE[SQLite DB<br/>FTS5 + Vectors]
    end

    subgraph "Configuration"
        DBCONFIG[databases.yaml<br/>Database connections]
        AGENTCONFIG[agent-config.yaml<br/>Agent behavior settings]
        PROMPTS[/prompts/*.md<br/>LLM prompt templates]
    end

        ORCHESTRATOR --> ORCHSTATE
        PLANNER --> PLANFILE
        AGENT1 --> FILESYSTEM
        AGENT2 --> SQLITE
        AGENT3 --> SQLITE
        
    subgraph "Prompt Templates (/prompts/)"
        PROMPTS[column-description.md<br/>Table column semantics]
        PROMPTS --> TABLEPROMPT[table-description.md<br/>Table purpose inference]
        PROMPTS --> DOMAINPROMPT[domain-inference.md<br/>Business domain grouping]
        PROMPTS --> QUERYPROMPT[query-understanding.md<br/>Search query interpretation]
    end
        
        PLANNER -.->|uses| PROMPTS
        TABLEDOC -.->|uses| PROMPTS
        COLINF -.->|uses| PROMPTS
        AGENT3 -.->|uses| PROMPTS
    end
    
    subgraph "External Systems"
        DBS[(Databases<br/>PostgreSQL<br/>Snowflake)]
        EXTMCP[External MCP Repo<br/>Noah's Company MCP]
        LLM[LLM APIs<br/>OpenAI<br/>Anthropic]
    end
    
    ORCHESTRATOR -->|coordinates| PLANNER
    PLANNER -->|connects| DBS
    AGENT1 -->|connects| DBS
    AGENT1 -->|calls| LLM
    AGENT2 -->|calls| LLM
    AGENT3 -->|functions| EXTMCP
    EXTMCP -->|queries| AGENT3
    
    style ORCHESTRATOR fill:#e1f5ff
    style PLANNER fill:#e1f5ff
    style AGENT1 fill:#e1f5ff
    style AGENT2 fill:#e1f5ff
    style AGENT3 fill:#e1f5ff
    style TABLEDOC fill:#fff4e1
    style COLINF fill:#fff4e1
    style ORCHSTATE fill:#e8f5e9
    style PLANFILE fill:#e8f5e9
    style FILESYSTEM fill:#e8f5e9
    style SQLITE fill:#e8f5e9
```

---

## 2. Agent Chain Flow

```mermaid
flowchart TD
    START[User Trigger<br/>npm run plan] --> PLANNER
    
    subgraph "Planner: Schema Analyzer"
        PLANNER[Planner] --> CONNECT[Connect to Databases]
        CONNECT --> COUNT[Count Tables]
        COUNT --> EXTRACT[Extract Metadata<br/>for ALL tables]
        EXTRACT --> DETECT[Detect Domains<br/>via LLM]
        DETECT --> CREATE[Create Plan<br/>documentation-plan.json]
    end
    
    CREATE --> PLANFILE[documentation-plan.json<br/>Contains complete metadata]
    PLANFILE --> REVIEW[User Reviews Plan]
    REVIEW --> DOCSTART[User Trigger<br/>npm run document]
    
    subgraph "Agent 1: Documenter"
        DOCSTART --> LOAD[Load Plan]
        LOAD --> PARALLEL[Process Work Units in Parallel<br/>Domain-based groups]

        subgraph "Work Unit Processing"
            PARALLEL --> SPAWN[Spawn TableDocumenter<br/>for each table in work unit]

            subgraph "Sub-Agent: TableDocumenter"
                SPAWN --> RECEIVE[Receive Complete Metadata<br/>from work unit]
                RECEIVE --> SAMPLE[Sample Data<br/>100 rows max]
                SAMPLE --> COLSPAWN[Spawn ColumnInferencer<br/>for each column]

                subgraph "Sub-Agent: ColumnInferencer"
                    COLSPAWN --> LOADPROMPT[Load column-description.md<br/>Prompt Template]
                    LOADPROMPT --> CALL[Call Claude API<br/>Semantic Inference]
                    CALL --> RETURN[Return Description String<br/>Context Quarantine]
                end

                RETURN --> ASSEMBLE[Assemble Documentation<br/>Markdown + JSON + YAML]
                ASSEMBLE --> WRITE[Write Files to /docs]
                WRITE --> SUMMARY[Return Summary<br/>Context Quarantine]
            end

            SUMMARY --> WORKCOMPLETE[Work Unit Complete]
        end

        WORKCOMPLETE --> CHECKPOINT[Update Progress<br/>documenter-progress.json]
        CHECKPOINT --> MORE{More work units?}
        MORE -->|Yes| PARALLEL
        MORE -->|No| AGGREGATE[Generate Aggregate Outputs<br/>documentation-manifest.json]
    end
    
    AGGREGATE --> DOCFILES[/docs/ filesystem]
    DOCFILES --> INDEXSTART[User Trigger<br/>npm run index]
    
    subgraph "Agent 2: Indexer"
        INDEXSTART --> PARSE[Parse Documentation]
        PARSE --> EXTRACTKW[Extract Keywords]
        EXTRACTKW --> GENEMB[Generate Embeddings]
        GENEMB --> BUILD[Build Index<br/>FTS5 + Vector]
    end
    
    BUILD --> SQLITEDB[(SQLite DB<br/>tribal-knowledge.db)]
    SQLITEDB --> RETRIEVAL[Agent 3: Retrieval<br/>Functions ready]
    
    RETRIEVAL --> EXTMCP[External MCP<br/>Calls Functions]
    
    style PLANNER fill:#e1f5ff
    style DOCSTART fill:#e1f5ff
    style INDEXSTART fill:#e1f5ff
    style RECEIVE fill:#fff4e1
    style COLSPAWN fill:#fff4e1
    style PLANFILE fill:#e8f5e9
    style DOCFILES fill:#e8f5e9
    style SQLITEDB fill:#e8f5e9
```

---

## 3. Data Flow Architecture

```mermaid
flowchart LR
    subgraph "Source"
        PG[(PostgreSQL)]
        SF[(Snowflake)]
    end
    
    subgraph "Planner Phase"
        PLANNER[Schema Analyzer] -->|Extracts ALL metadata| PLAN[documentation-plan.json<br/>Work units by domain]
        PLANNER -->|calls| LLM0[Claude API<br/>Domain Inference]
    end

    PG -->|connection| PLANNER
    SF -->|connection| PLANNER

    PLAN -->|work units| DOCUMENTER[Documenter]

    subgraph "Documentation Phase"
        DOCUMENTER -->|parallel processing| TABLEDOC[TableDocumenter Sub-agents<br/>Per work unit]
        TABLEDOC -->|samples| PG
        TABLEDOC -->|samples| SF
        TABLEDOC -->|calls| LLM1[Claude API<br/>Column + Table Descriptions]
        TABLEDOC -->|generates| DOCS[Markdown + JSON + YAML<br/>Per table]
        DOCUMENTER -->|aggregates| MANIFEST[documentation-manifest.json<br/>Handoff to Indexer]
    end

    MANIFEST -->|input| INDEXER[Indexer]
    
    subgraph "Indexing Phase"
        INDEXER -->|calls| LLM2[OpenAI API<br/>Embeddings]
        INDEXER -->|writes| DB[(SQLite DB<br/>FTS5 + Vectors)]
    end
    
    subgraph "Retrieval Phase"
        DB -->|queries| RETRIEVAL[Retrieval Functions]
        RETRIEVAL -->|calls| LLM3[Query Understanding]
        RETRIEVAL -->|returns| EXTMCP[External MCP]
    end
    
    style PLANNER fill:#e1f5ff
    style DOCUMENTER fill:#e1f5ff
    style INDEXER fill:#e1f5ff
    style RETRIEVAL fill:#e1f5ff
    style TABLEDOC fill:#fff4e1
    style PLAN fill:#e8f5e9
    style DOCS fill:#e8f5e9
    style DB fill:#e8f5e9
```

---

## 4. Sub-Agent Architecture Detail

```mermaid
graph TB
    PLANNER[Planner] -->|Creates work units| PLAN[documentation-plan.json<br/>Tables grouped by domain]

    DOCUMENTER[Documenter<br/>Agent 1] -->|Processes work units| WORKUNIT[Work Unit<br/>Domain + Tables]

    subgraph "TableDocumenter Sub-Agent"
        WORKUNIT --> SPAWN[Spawn TableDocumenter<br/>Per table in work unit]
        SPAWN --> RECEIVE[Receive Complete Metadata<br/>from work unit]
        RECEIVE --> VALIDATE[Validate Metadata Structure]
        VALIDATE --> SAMPLE[Sample Data from Table<br/>100 rows max]
        SAMPLE --> COLSPAWN[Spawn ColumnInferencer<br/>for each column]

        COLSPAWN --> COLLECT[Collect Column Descriptions]
        COLLECT --> TABLEDESC[Generate Table Description<br/>via LLM + table-description.md]
        TABLEDESC --> ASSEMBLE[Assemble Documentation<br/>Markdown + JSON + YAML]
        ASSEMBLE --> WRITE[Write Files to /docs<br/>Per table]
        WRITE --> RETURN[Return Summary<br/>Context Quarantine]
    end

    subgraph "ColumnInferencer Sub-Agent"
        COLSPAWN --> COLRECEIVE[Receive Column Metadata<br/>+ Sample Values]
        COLRECEIVE --> LOADPROMPT[Load column-description.md<br/>Prompt Template]
        LOADPROMPT --> FORMAT[Format Prompt<br/>Substitute variables]
        FORMAT --> CALL[Call Claude API<br/>Semantic Inference]
        CALL --> PARSE[Parse Response<br/>Validate output]
        PARSE --> COLRETURN[Return Description String<br/>Context Quarantine]
    end

    COLRETURN --> COLLECT
    RETURN --> WORKUNIT
    WORKUNIT --> DOCUMENTER

    subgraph "Deep Agent Principles"
        PRINCIPLE1[Planning Tool<br/>Schema Analyzer creates plan first]
        PRINCIPLE2[Sub-agents<br/>Delegate repeated tasks]
        PRINCIPLE3[Filesystem Memory<br/>Persistent external state]
        PRINCIPLE4[System Prompts<br/>Configurable LLM behavior]
        PRINCIPLE5[Context Quarantine<br/>Return summaries only]
        PRINCIPLE6[Domain Parallelization<br/>Work units processed concurrently]
    end

    style DOCUMENTER fill:#e1f5ff
    style SPAWN fill:#fff4e1
    style COLSPAWN fill:#fff4e1
    style RETURN fill:#e8f5e9
    style COLRETURN fill:#e8f5e9
```

---

## 5. Storage Architecture

```mermaid
graph TB
    subgraph "Filesystem Storage"
        DOCS[/docs/]
        DOCS --> CATALOG[catalog-summary.md]
        DOCS --> DBS[databases/]

        DBS --> DB1[production_postgres/]
        DB1 --> TABLES1[tables/<br/>*.md, *.json, *.yaml]
        DB1 --> DOMAINS1[domains/<br/>*.md, *.mermaid]
        DB1 --> ER1[er-diagrams/<br/>*.mermaid]
        DB1 --> SCHEMAS1[schemas/<br/>*.json, *.yaml]

        DBS --> DB2[analytics_snowflake/]
        DB2 --> TABLES2[tables/]
        DB2 --> DOMAINS2[domains/]
        DB2 --> ER2[er-diagrams/]
        DB2 --> SCHEMAS2[schemas/]

        PROGRESS[progress/]
        PROGRESS --> PLANFILE[documentation-plan.json<br/>Work units by domain]
        PROGRESS --> DOCPROG[documenter-progress.json<br/>Per-work-unit status]
        PROGRESS --> IDXPROG[indexer-progress.json<br/>Indexing checkpoints]
        PROGRESS --> ORCHSTATE[orchestrator-state.json<br/>Pipeline coordination]

        DOCS --> MANIFEST[documentation-manifest.json<br/>Handoff to Indexer]
    end
    
    subgraph "SQLite Database"
        SQLITE[(tribal-knowledge.db)]
        
        SQLITE --> DOCS_TABLE[documents table<br/>id, type, content, metadata]
        SQLITE --> FTS5[documents_fts<br/>FTS5 full-text search]
        SQLITE --> VEC[documents_vec<br/>Vector embeddings]
        SQLITE --> REL[relationships table<br/>Join paths, FKs]
        SQLITE --> KW[keywords table<br/>Term cache]
        SQLITE --> WEIGHTS[index_weights<br/>Search boosts]
        
        DOCS_TABLE --> FTS5
        DOCS_TABLE --> VEC
    end
    
    subgraph "Prompt Templates"
        PROMPTS[/prompts/]
        PROMPTS --> COLPROMPT[column-description.md]
        PROMPTS --> TABPROMPT[table-description.md]
        PROMPTS --> DOMPROMPT[domain-inference.md]
        PROMPTS --> QUERYPROMPT[query-understanding.md]
    end
    
    DOCS -.->|indexed by| SQLITE
    PLANFILE -.->|used by| DOCUMENTER[Documenter]
    
    style DOCS fill:#e8f5e9
    style SQLITE fill:#e8f5e9
    style PROMPTS fill:#fff4e1
    style PROGRESS fill:#e1f5ff
```

---

## 6. Integration Architecture

```mermaid
graph TB
    subgraph "Tribal Knowledge Repo"
        RETRIEVAL[Retrieval Functions<br/>Agent 3]
        
        RETRIEVAL --> SEARCH[search_tables]
        RETRIEVAL --> SCHEMA[get_table_schema]
        RETRIEVAL --> JOIN[get_join_path]
        RETRIEVAL --> DOMAIN[get_domain_overview]
        RETRIEVAL --> LIST[list_domains]
        RETRIEVAL --> RELS[get_common_relationships]
        
        SEARCH --> HYBRID[Hybrid Search<br/>FTS5 + Vector + RRF]
        SCHEMA --> LOOKUP[Direct Lookup]
        JOIN --> GRAPH[Relationship Graph]
        DOMAIN --> QUERY[Domain Query]
        LIST --> DISTINCT[Distinct Query]
        RELS --> PATTERNS[Pattern Query]
        
        HYBRID --> SQLITE[(SQLite DB)]
        LOOKUP --> SQLITE
        GRAPH --> SQLITE
        QUERY --> SQLITE
        DISTINCT --> SQLITE
        PATTERNS --> SQLITE
    end
    
    subgraph "External MCP Repo"
        MCP[MCP Server]
        MCP --> TOOL1[MCP Tool: search_tables]
        MCP --> TOOL2[MCP Tool: get_table_schema]
        MCP --> TOOL3[MCP Tool: get_join_path]
        MCP --> TOOL4[MCP Tool: get_domain_overview]
        MCP --> TOOL5[MCP Tool: list_domains]
        MCP --> TOOL6[MCP Tool: get_common_relationships]
    end
    
    subgraph "External Agents"
        AGENT[AI Agent<br/>via MCP]
        AGENT -->|calls| MCP
    end
    
    TOOL1 -.->|calls| SEARCH
    TOOL2 -.->|calls| SCHEMA
    TOOL3 -.->|calls| JOIN
    TOOL4 -.->|calls| DOMAIN
    TOOL5 -.->|calls| LIST
    TOOL6 -.->|calls| RELS
    
    style RETRIEVAL fill:#e1f5ff
    style MCP fill:#fff4e1
    style AGENT fill:#e8f5e9
    style SQLITE fill:#e8f5e9
```

---

## 7. Orchestrator Architecture

```mermaid
graph TB
    USER[User] -->|npm run orchestrate| ORCH[Orchestrator]

    subgraph "Orchestrator"
        ORCH --> STATE[State Manager<br/>Analyzes filesystem state]
        STATE --> DECIDE[Decision Logic<br/>What needs to run?]
        DECIDE --> RUNNER[Phase Runner]

        RUNNER -->|calls| PLANNER[Planner]
        RUNNER -->|calls| DOCUMENTER[Documenter]
        RUNNER -->|calls| INDEXER[Indexer]
        RUNNER -->|calls| SERVE[Serve]

        RUNNER --> UI[Interactive UI<br/>Pause points, prompts]
        UI --> USER
    end

    subgraph "State Detection"
        STATE --> CHECK1{Plan exists?}
        STATE --> CHECK2{Docs fresh?}
        STATE --> CHECK3{Index fresh?}
        STATE --> CHECK4{Config changed?}
    end

    CHECK1 -->|No| REC1[Recommend: Run plan]
    CHECK2 -->|No| REC2[Recommend: Run document]
    CHECK3 -->|No| REC3[Recommend: Run index]
    CHECK4 -->|Yes| REC1

    REC1 --> RUNNER
    REC2 --> RUNNER
    REC3 --> RUNNER

    style ORCH fill:#e1f5ff
    style STATE fill:#fff4e1
    style RUNNER fill:#fff4e1
    style UI fill:#e8f5e9
```

---

## 8. Component Relationships

```mermaid
graph LR
    subgraph "Core Agents"
        P[Planner]
        D[Documenter]
        I[Indexer]
        R[Retrieval]
    end
    
    subgraph "Sub-Agents"
        TD[TableDocumenter]
        CI[ColumnInferencer]
    end
    
    subgraph "Connectors"
        PG[PostgreSQL Connector]
        SF[Snowflake Connector]
    end
    
    subgraph "Search"
        HYBRID[Hybrid Search]
        FTS5[FTS5 Engine]
        VEC[Vector Search]
        RRF[RRF Ranking]
    end
    
    subgraph "Storage"
        PLAN[Plan File]
        FS[Filesystem]
        DB[(SQLite)]
    end
    
    subgraph "External"
        LLM[LLM APIs]
        PROMPTS[Prompt Templates]
        EXTMCP[External MCP]
    end
    
    P --> PG
    P --> SF
    P --> LLM
    P --> PROMPTS
    P --> PLAN
    
    D --> PLAN
    D --> TD
    TD --> CI
    TD --> PG
    TD --> SF
    TD --> LLM
    TD --> PROMPTS
    D --> FS
    
    I --> FS
    I --> LLM
    I --> DB
    
    R --> DB
    R --> HYBRID
    HYBRID --> FTS5
    HYBRID --> VEC
    HYBRID --> RRF
    R --> PROMPTS
    R --> EXTMCP
    
    style P fill:#e1f5ff
    style D fill:#e1f5ff
    style I fill:#e1f5ff
    style R fill:#e1f5ff
    style TD fill:#fff4e1
    style CI fill:#fff4e1
    style PLAN fill:#e8f5e9
    style FS fill:#e8f5e9
    style DB fill:#e8f5e9
```

---

## Key Architectural Principles

### Deep Agent Properties
1. **Planning Tool**: Schema Analyzer creates documentation plan before execution, enabling user review and domain-based organization.

2. **Sub-agents**: TableDocumenter and ColumnInferencer handle repeated tasks with context quarantine - they return summaries only, preventing context window overflow.

3. **Filesystem Memory**: Persistent external memory via /docs, /progress, and SQLite - survives interruptions and enables resumability.

4. **System Prompts**: Configurable prompt templates in /prompts directory enable consistent LLM behavior and organization-specific customization.

### Domain-Based Parallelization
5. **Work Units**: Tables grouped by business domain into self-contained work units that can be processed concurrently.

6. **Documentation Manifest**: Structured handoff contract between Documenter and Indexer with file integrity verification.

### Search & Retrieval
7. **Hybrid Search**: Combines FTS5 (keyword) + vector embeddings (semantic) with Reciprocal Rank Fusion for optimal results.

8. **Context Budgeting**: Adaptive token limits based on query complexity ensure responses fit within LLM context windows.

### Integration
9. **MCP Tools**: Retrieval functions exposed as MCP tools in separate repository for external agent consumption.

10. **Manual Control**: User-triggered phases with optional orchestrator for intelligent pipeline coordination.

